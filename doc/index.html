<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>iPiano: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">iPiano
   </div>
   <div id="projectbrief">An implementation of the iPiano algorithms for non-convex and non-smooth optimization.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">iPiano Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="classiPiano.html" title="Implementation of iPiano (algorithm 5) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">iPiano</a>, proposed in [1], is an optimization algorithm combining forward-backward splitting with an inertial force. This repository contains a C++ implementation of <a class="el" href="classiPiano.html" title="Implementation of iPiano (algorithm 5) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">iPiano</a> with applications to computer vision tasks. The implementation was submitted as part of a seminar paper [2] written at RWTH Aachen University and advised by <a href="https://www.aices.rwth-aachen.de/people/berkels">Prof. Berkels</a>. </p>
<pre class="fragment">[1] P. Ochs, Y. Chen, T. Brox, T. Pock.
    iPiano: Inertial Proximal Algorithm for Nonconvex Optimization
    SIAM Journal of Imaging Sciences, colume 7, number 2, 2014.
[2] D. Stutz.
    Seminar paper "iPiano: Inertial Proximal Algorithm for Non-Convex Optimization"
    https://github.com/davidstutz/seminar-ipiano
</pre><h2>Introduction</h2>
<p>Similar to forward-backward splitting, the algorithm tackles problems of the form </p>
<pre class="fragment">h(x) = f(x) + g(x)
</pre><p>where h and g are functions defined on <code>\mathbb{R}^n</code> with different properties. In the most general setting, f is required to be smooth and g is required to be convex. The iterative algorithm is then described by the following update equation: </p>
<pre class="fragment">x^{(n + 1)} = \prox_{\alpha_n g}(x{(n)} - \nabla f(x{(n)}) + \beta_n (x^{(n)} - x^{(n - 1)}))
</pre><p>where <code>x^{(n)}</code> is the <code>n</code>-th iterate, <code>\alpha_n</code> and <code>\beta_n</code> are parameters, <code>\prox_{\alpha_n g}</code> is the proximal mapping of g and <code>\nabla f</code> is the gradient of f. Details can be found in [1] or the seminar paper corresponding to this implementation [2].</p>
<p>This implementation provides two variants of the algorithm: <a class="el" href="classnmiPiano.html" title="Implementation of nmiPiano (algorithm 4) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">nmiPiano</a> and <a class="el" href="classiPiano.html" title="Implementation of iPiano (algorithm 5) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">iPiano</a>. Ochs et al. [1] proved convergence of the latter one, while the former one is a simplified version. The algorithm can be applied to various tasks, as for example segmentation:</p>
<div class="image">
<img src="screenshot.png?raw=true"  alt="Example: segmentations obtained for different thresholds, see [2]." title="Example: segmentations obtained for different thresholds, see [2]"/>
</div>
<h2>Building</h2>
<p>The project is based on <a href="https://cmake.org/">CMake</a>, <a href="http://www.boost.org/doc/libs/1_57_0/doc/html/boost_random/performance.html">Boost</a>, <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>, <a href="https://github.com/google/glog">GLog</a> as well as <a href="http://docs.opencv.org/2.4/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation">OpenCV</a> (tested with OpenCV 2.x) and has been tested on Ubuntu 12.04 and Ubuntu 14.04: </p>
<pre class="fragment">sudo apt-get install build-essential cmake libeigen3-dev libboost-all-dev
</pre><p>For installation instructions of GLog and OpenCV, please see consult the respective web pages. The project is then compiled using: </p>
<pre class="fragment">git clone https://github.com/davidstutz/ipiano
cd ipiano
mkdir build
cd build
cmake ..
make
Scanning dependencies of target signal_denoising_cli
[ 25%] Building CXX object signal_denoising_cli/CMakeFiles/signal_denoising_cli.dir/main.cpp.o
Linking CXX executable signal_denoising_cli
[ 25%] Built target signal_denoising_cli
Scanning dependencies of target image_denoising_cli
[ 50%] Building CXX object image_denoising_cli/CMakeFiles/image_denoising_cli.dir/main.cpp.o
Linking CXX executable image_denoising_cli
[ 50%] Built target image_denoising_cli
Scanning dependencies of target phase_field_cli
[ 75%] Building CXX object phase_field_cli/CMakeFiles/phase_field_cli.dir/main.cpp.o
Linking CXX executable phase_field_cli
[ 75%] Built target phase_field_cli
Scanning dependencies of target phase_field_color_cli
[100%] Building CXX object phase_field_color_cli/CMakeFiles/phase_field_color_cli.dir/main.cpp.o
Linking CXX executable phase_field_color_cli
[100%] Built target phase_field_color_cli
</pre><p><b>The modules in <code>cmake/</code> may have to be adapted depending on the Eigen and GLog installations!</b></p>
<h2>Examples</h2>
<h2>Usage</h2>
<p>Usage can be illustrated using the example of one-dimensional signal denoising as done in <code>signal_denoising_cli</code>. The below code example shows the basic usage, also note the discussion below. </p>
<pre class="fragment">// We randomly sample a signal in the form of a Nx1 Eigen matrix:
Eigen::MatrixXf signal;
sampleSignal(signal);

// perturbed_signal is the noisy signal we intend to denoise:
Eigen::MatrixXf perturbed_signal = signal;
perturbSignal(perturbed_signal);

// Basic denoising functionals are provided in functionals.h
// f_forentzianPairwise is a regularizer based on the lorentzian function;
// i.e. it is differentiable but not convex.
// g_absoluteUnary is an absolute data term which is convex but not differentiable.
// The corresponding gradient and proximal mapping are implemented in functionals.h
// and described in detail in [2].
std::function&lt;float(const Eigen::MatrixXf&amp;)&gt; bound_f 
        = std::bind(Functionals::Denoising::f_lorentzianPairwise, std::placeholders::_1, sigma, lambda);
std::function&lt;void(const Eigen::MatrixXf&amp;, Eigen::MatrixXf&amp;)&gt; bound_df 
        = std::bind(Functionals::Denoising::df_lorentzianPairwise, std::placeholders::_1, std::placeholders::_2, sigma, lambda);
std::function&lt;float(const Eigen::MatrixXf&amp;)&gt; bound_g
        = std::bind(Functionals::Denoising::g_absoluteUnary, std::placeholders::_1, perturbed_signal);
std::function&lt;void(const Eigen::MatrixXf&amp;, Eigen::MatrixXf&amp;, float)&gt; bound_prox_g
        = std::bind(Functionals::Denoising::prox_g_absoluteUnary, std::placeholders::_1, perturbed_signal, std::placeholders::_2, std::placeholders::_3);

// The initial iterate (i.e. starting point) will be a random signal.
Eigen::MatrixXf x_0 = Eigen::MatrixXf::Zero(M, 1);
perturbSignal(x_0);

// nmiPiano provides the following options, see nmipiano.h or the discussion below.
nmiPiano::Options nmi_options;
nmi_options.x_0 = x_0;
nmi_options.max_iter = 1000;
nmi_options.L_0m1 = 100.f;
nmi_options.beta = 0.5;
nmi_options.eta = 1.05;
nmi_options.epsilon = 1e-8;

// Both nmiPiano and iPiano provide callbacks to monitor progress.
// The default_callback writes progress to std::cout, other callbacks to
// write the progress to file are available in nmipiano.h and ipiano.h
std::function&lt;void(const nmiPiano::Iteration &amp;iteration)&gt; nmi_bound_callback 
        = std::bind(nmiPiano::default_callback, std::placeholders::_1, 10);

// For initialization, we provide f and g as well as their gradient/proximal mapping,
// and the callback defined above.
nmiPiano nmipiano(bound_f, bound_df, bound_g, bound_prox_g, nmi_options, 
        nmi_bound_callback);

// Optimization is done via .optimize expecting two arguments which will be the
// final iterate as well as the corresponding function value (i.e. h = f + g)
Eigen::MatrixXf nmi_x_star;
float nmi_f_x_star;
nmipiano.optimize(nmi_x_star, nmi_f_x_star);
</pre><p>The corresponding usage of <a class="el" href="classiPiano.html" title="Implementation of iPiano (algorithm 5) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">iPiano</a> can be found in <code>signal_denoising_cli</code>. The functional to be optimized has to be provided as <code>std::function</code> and is expected to have the following form: </p>
<pre class="fragment">static float f(const Eigen::MatrixXf &amp;x);
static void df_lorentzianPairwise(const Eigen::MatrixXf &amp;x, Eigen::MatrixXf &amp;df_x);
static float g_absoluteUnary(const Eigen::MatrixXf &amp;x);
static void prox_g_absoluteUnary(const Eigen::MatrixXf &amp;x, Eigen::MatrixXf &amp;prox_f_x, float alpha);
</pre><p>Additional parameters are possible but have to be provided through <code>std::bind</code>, as for example done with <code>g_absoluteUnary</code> which in addition to the above parameters also expects the noisy signal in order to implement the absolute data term: </p>
<pre class="fragment">// Bind g_absoluteUnary such that the resulting std::function matches the above form!
// Use std::placeholder::_1, std::placeholder::_2 etc. ...
std::function&lt;float(const Eigen::MatrixXf&amp;)&gt; bound_g
        = std::bind(Functionals::Denoising::g_absoluteUnary, std::placeholders::_1, perturbed_signal);
</pre><p><a class="el" href="classnmiPiano.html" title="Implementation of nmiPiano (algorithm 4) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">nmiPiano</a> provides the following parameters (default values and documentation can also be found in <code><a class="el" href="nmipiano_8h_source.html">nmipiano.h</a></code>):</p>
<ul>
<li><code>x_0</code>: the initial iterate;</li>
<li><code>max_iter</code>: maximum number of iterations;</li>
<li><code>beta</code>: fixed <code>\beta</code>, i.e. the parameter governing the momentum term/inertial force;</li>
<li><code>eta</code>: parameter for backtracking to find the local Lipschitz-constant L_n in each iteration, see [1] or [2];</li>
<li><code>L_0m1</code>: initial estimate of the local Lipschitz-constant; during initialization, the local Lipschitz-constant is estimated around <code>x_0</code> and the maximum of the estimate and <code>L_0m1</code> is taken;</li>
<li><code>BOUND_L_N</code>: if true, the local Lipschitz-constant is always bounded below by <code>L_0m1</code>;</li>
<li><code>epsilon</code>: stopping criterion; if <code>epsilon</code> is greater than zero, iterations stop if the squared norm of the difference of two consecutive iterates is smaller than <code>epsilon</code>.</li>
</ul>
<p>Choosing these parameters needs some practice; reading [1] and/or [2] is highly recommended. In addition, the parameters strongly depend on the function to be optimized (e.g. if <a class="el" href="classnmiPiano.html" title="Implementation of nmiPiano (algorithm 4) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">nmiPiano</a> or <a class="el" href="classiPiano.html" title="Implementation of iPiano (algorithm 5) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">iPiano</a> do not converge for a given functional, try starting with a higher <code>L_0m1</code>).</p>
<p><a class="el" href="classiPiano.html" title="Implementation of iPiano (algorithm 5) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">iPiano</a> <b>additionally</b> provides the following parameters (also see <code><a class="el" href="ipiano_8h_source.html">ipiano.h</a></code>):</p>
<ul>
<li><code>beta_0m1</code>: initial <code>\beta</code>, i.e. the parameter governing the momentum term/inertial force - after the first iteration, <code>\beta</code> is adapted automatically;</li>
<li><code>c_1</code>: <code>c_1</code> from [1] and [2], usually close to zero is fine, e.g. <code>c_1 = 1e-6</code> to <code>c_1 = 1e-12</code>;</li>
<li><code>c_2</code>: same as <code>c_1</code>;</li>
<li><code>steps</code>: governs the resolution of finding appropriate <code>\alpha_n</code> and <code>\beta_n</code> in each iteration in order to guarantee convergence, see [2]; starting with high <code>steps &gt; 10000</code> is recommended - it can later be reduced depending on the functional.</li>
</ul>
<p>Independent of the function or the used variant, <b>reading [1] and [2] is highly recommended!</b></p>
<p>Further functionals can be found in <code><a class="el" href="functionals_8h_source.html">functionals.h</a></code> and another example can be found in <code>image_denoising_cli</code> or <code>phase_field_color_cli</code>.</p>
<h2>Examples</h2>
<p>This repository contains 4 examples for using <a class="el" href="classnmiPiano.html" title="Implementation of nmiPiano (algorithm 4) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">nmiPiano</a> and <a class="el" href="classiPiano.html" title="Implementation of iPiano (algorithm 5) as proposed in [1]: [1] P. Ochs, Y. Chen, T. Brox, T. Pock. iPiano: Inertial Proximal Algorithm for Nonconvex Optimization. SIAM J. Imaging Sciences, vol. 7, no. 2, 2014. ">iPiano</a>:</p>
<ul>
<li>signal denoising: <code>signal_denoising_cli</code>;</li>
<li>image denoising: <code>image_denoising_cli</code>;</li>
<li>phase field segmentation of grayscale images: <code>phase_field_cli</code>;</li>
<li>and phase field segmentation of color images: <code>phase_field_color_cli</code>.</li>
</ul>
<p>The corresponding functions are detailed in [2]. Some examples are given below: </p>
<pre class="fragment">cd build
cmake ..
make
# Opencv 4 windows containing the original, noisy and denoised signals!
./signal_denoising_cli/signal_denoising_cli
[0] 79.8015 (Delta_n = 4.23812e-38; L_n = 100; alpha_n = 0.01)
[10] 50.5144 (Delta_n = 0.0272214; L_n = 653.026; alpha_n = 0.00153133)
[20] 48.6092 (Delta_n = 0.0286435; L_n = 480.716; alpha_n = 0.00208023)
[30] 46.641 (Delta_n = 0.0291762; L_n = 463.074; alpha_n = 0.00215948)
[40] 44.6816 (Delta_n = 0.0290498; L_n = 461.657; alpha_n = 0.00216611)
[50] 42.7609 (Delta_n = 0.0285756; L_n = 462.503; alpha_n = 0.00216215)
# ...
# Applies different functionals for denoising the image with added Gaussian noise:
./image_denoising_cli/image_denoising_cli ../3096.jpg
[0] 16963.7 (Delta_n = 1.65681e-37; L_n = 14.1274; alpha_n = 0.0707846)
[10] 6109.42 (Delta_n = 1.39415; L_n = 209.762; alpha_n = 0.00476731)
[20] 6004.02 (Delta_n = 0.078446; L_n = 180.711; alpha_n = 0.00553371)
[30] 6002.3 (Delta_n = 0.0352952; L_n = 181.006; alpha_n = 0.00552467)
[40] 6001.82 (Delta_n = 0.0147341; L_n = 181.044; alpha_n = 0.00552353)
[50] 6001.69 (Delta_n = 0.0121218; L_n = 181.051; alpha_n = 0.00552331)
# Applies a color phase field to segmentation (iteratively):
./phase_field_color_cli/phase_field_color_cli ../3096.jpg
[0] 4.49466e+07 (Delta_n = 6.45593e-38; L_n = 8.61429; alpha_n = 0.116086)
[10] 4.48568e+07 (Delta_n = 34.6824; L_n = 8.81607; alpha_n = 0.113429)
[20] 4.48357e+07 (Delta_n = 19.3647; L_n = 6.77839; alpha_n = 0.147528)
[30] 4.48274e+07 (Delta_n = 13.7736; L_n = 7.1557; alpha_n = 0.139749)
[40] 4.48222e+07 (Delta_n = 10.3676; L_n = 7.2935; alpha_n = 0.137108)
[50] 4.48188e+07 (Delta_n = 9.12528; L_n = 6.54973; alpha_n = 0.152678)
# ... 
[0] C_p = 0.43245,0.454655,0.534252; C_m = 0.44876,0.471163,0.554002
# ...
[1] C_p = 0.342906,0.36354,0.445063; C_m = 0.488703,0.512195,0.593856
# ...
[2] C_p = 0.303374,0.322877,0.399622; C_m = 0.479937,0.503389,0.586667
# ...
</pre><p>The provided example image is taken from the Berkeley Segmentation Dataset [3]. </p>
<pre class="fragment">[3] P. Arbelaez, M. Maire, C. Fowlkes and J. Malik.
    Contour Detection and Hierarchical Image Segmentation.
    Transactions on Pattern Analysis and Machine Intelligence, volume 33, number 5, 2011.
</pre><p>Example segmentations are shown in the introduction.</p>
<h2>License</h2>
<p>Copyright (c) 2016, David Stutz All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. *Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 8 2016 19:21:48 for iPiano by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
